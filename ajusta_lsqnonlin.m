function [fitparam, allparam, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, JACOB] = ajusta_lsqnonlin(FUN, guess, LB, UB, options, xdata, ydata, yerr, indparamvariables, indparamfijos, valorparamfijos)%% [fitparam, allparam, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, JACOB] =...%   ajusta_lsqnonlin(FUN, guess, LB, UB, options, xdata, ydata, yerr, indparamvariables, indparamfijos, valorparamfijos)%% Ajusta_lsqnonlin usa lsqnonlin para ajustar una función con parámetros fijos.%% Hay que tener cuidado entre pasar el peso o el error de los datos. % ajusta_lsqnonlin pide el error (lo divide), no el peso (multiplicativo).% Es probable que haya una versión anterior que pida el peso y no el error.%% FUN es un handle a la función de ajuste% xdata los valores de x% ydata los valores experimentales% yerr el error en cada punto de ydata% guess la hipótesis inicial% indparamvariables los índices de los parámetros variables% indparamfijos los índices de los parámetros fijos% valorparamfijos el valor de los parámetros fijos% LB, UB y options son los mismos que en lsqnonlin%% A diferencia de lsqnonlin, la función de error no hay que meterla en un% archivo aparte% Los parámetros que devuelve son los mismos que lsqnonlin, incluyendo un% vector extra (allparam) que contiene el valor de los parámetros ajustados% (también incluidos en fitparam) y el de los fijos (ya pasados en% valorparamfijos) en el orden correcto para FUN%% resnorm es la suma de los residuos normalizados a su error al cuadrado% resfun son los residuos normalizados al error:%       resfun:=(FUN(xdata)-ydata)./yerr%%Esto permite calcular el Chi2 reducido dividiendo entre el número de grados de libertad:%       Chi2:=resnorm=sum(resfun.^2);%       Chi2_reduced:=sum(((ydata-FUN(xdata))./yerror).^2)/(numel(ydata)-numel(indparamvariables));%       Chi2:_reduced=resnorm/(numel(ydata)-numel(indparamvariables)):%% Por ejemplo, si mycurve es un archivo que contiene la siguiente función%   function m = mycurve(parameter, x)%   m = parameter(1)*exp(parameter(2).*x)+parameter(3);%% Entonces, %   FUN=@mycurve %   t=0:.1:10; t=t(:); % hace t un vector columna, pero creo que no es%   necesario?%   Data=mycurve([40 -0.5 0];     % o lo que es lo mismo Data=40*exp(-.5*t);%   ydata=Data+poissrnd(Data);%   yerr=sqrt(ydata); % El error%%   indparamvariables=[1 3];%   indparamfijos=2;%   valorparamfijos=-0.5; %   guess=[80 0];% [fitparam, allparam]= ajusta_lsqnonlin(@mycurve,[],[],[],t,ydata, yerr, indparamvariables, guess, indparamfijos, valorparamfijos)%%ajusta_lsqnonlin ajustaría para parameter(1) y parameter(3) y dejaría fijo%parameter(2) con valor de -0.5%% Si se quieren ajustar todos los parámetros entonces indparamvariables=[1 2 3] y indparamfijos=[]%% jri 27-Dec-2010% jri 26-Sep-2012if numel (indparamvariables)~=numel (guess)    error ('El número de parámetros variables tiene que ser igual que el de las hipótesis')endif numel (indparamfijos)~=numel (valorparamfijos)    error ('El número de parámetros fijos tiene que ser igual que el de número de valores indicados')endif numel(indparamvariables)+numel(indparamfijos)~=numel(guess)+numel(valorparamfijos)    error ('La suma de los parámetros fijos y variables tiene que ser igual que a la suma de valores iniciales (guess) y los parámetros fijos')endxdata=xdata(:);ydata=ydata(:);yerr=yerr(:);[fitparam, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, JACOB] =...    lsqnonlin(@err_curve, guess, LB, UB, options, FUN, xdata, ydata, yerr, indparamvariables, indparamfijos, valorparamfijos);numtotalparams=numel(guess)+numel(indparamfijos);allparam = zeros (1, numtotalparams);allparam (indparamfijos)=valorparamfijos;allparam (indparamvariables)=fitparam;function err = err_curve (parameter, FUN, xdata, ydata, yerr, indparamvariables, indparamfijos, valorparamfijos)%Hay una función err_curve en fluoajusta que tiene en cuenta el intervalo%de ajustenumtotalparams=numel(parameter)+numel(indparamfijos);params=zeros (numtotalparams,1);params (indparamfijos)=valorparamfijos;params (indparamvariables)=parameter;% weight the error according to the |yerr| vectoryfit = FUN (params, xdata);err = (yfit - ydata)./yerr;