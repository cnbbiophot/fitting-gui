function [paramfitY, allparam, indparamvariables, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, J] =...    ajusta_lsqnonlin_global_gui(valorParamVarIni, LB, UB, data_all,...    indparamvariables, indparamfijos, valorparamfijos,...     numPtosxCurva, varGlobales, indParamsGlobal2Indep, varFix, funcAjuste)% ajusta_lsqnonlin_global usa lsqnonlin para ajustar una función con parámetros fijos y parámetros globales.%% Hay que tener cuidado entre pasar el peso o el error de los datos. % ajusta_lsqnonlin_global pide el error (lo divide), no el peso (multiplicativo).% Es probable que haya una versión anterior que pida el peso y no el error.%% INPUTS% valorParamVarIni - valores iniciales de las variables a ajustar% LB, UB - Lower y Upper bound de cada variable a ajustar% options - opciones para la función lsqnonlin% data_all - datos para ajustar en la forma [x, dsid, yData, yErr]% indparamvariables - vector con los índices de los parámetros variables% indparamfijos - vector con los índices de los parámetros fijos% valorparamfijos - valores de los parámetros fijos% numPtosxCurva - número de puntos por curva% varGlobales - vector lógico con las variables globales o individuales% indParamsGlobal2Indep - matriz de la forma (nºcurva, índice parámetro)% varFix - vector lógico con las variables fijas y variables% funcAjuste - nombre de la función de ajuste% % OUTPUTS% paramfitY - Parámetros ajustados con lsqnonlin. Misma dimensión que paramsIni. % allparams - Vector con todos los parámetros, los fijos y los ajustados, con el mismo orden que paramsIni.% J - Jacobiano de la función.% resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA - outputs de la función lsqnonlin%% Los parámetros que devuelve son los mismos que lsqnonlin, incluyendo un% vector extra (allparam) que contiene el valor de los parámetros ajustados% (también incluidos en paramfitY) y el de los fijos (ya pasados en% valorparamfijos).%% resnorm es la suma de los residuos normalizados a su error al cuadrado% resfun son los residuos normalizados al error:%       resfun:=(FUNCTION(xdata)-ydata)./yerr%%Esto permite calcular el Chi2 reducido dividiendo entre el número de grados de libertad:%       Chi2:=resnorm=sum(resfun.^2);%       Chi2_reduced:=sum(((ydata-FUN(xdata))./yerror).^2)/(numel(ydata)-numel(indparamvariables));%       Chi2:_reduced=resnorm/(numel(ydata)-numel(indparamvariables)):%% EJEMPLO DE LA FUNCIÓN CON SU ESTADO ANTERIOR (AHORA TIENE INPUTS Y% OUTPUTS ALGO DIFERENTES)% Por ejemplo, si mycurve es un archivo que contiene la siguiente función%   function m = mycurve(parameter, x)%   m = parameter(1)*exp(parameter(2).*x)+parameter(3);%% Entonces, %   FUN=@mycurve %   t=0:.1:10; t=t(:); % hace t un vector columna, pero creo que no es%   necesario?%   Data=mycurve([40 -0.5 0];     % o lo que es lo mismo Data=40*exp(-.5*t);%   ydata=Data+poissrnd(Data);%   yerr=sqrt(ydata); % El error%%   indparamvariables=[1 3];%   indparamfijos=2;%   valorparamfijos=-0.5; %   guess=[80 0];% [paramfitY, allparam]= ajusta_lsqnonlin(@mycurve,[],[],[],t,ydata, yerr, indparamvariables, guess, indparamfijos, valorparamfijos)%%ajusta_lsqnonlin ajustaría para parameter(1) y parameter(3) y dejaría fijo%parameter(2) con valor de -0.5%% Si se quieren ajustar todos los parámetros entonces indparamvariables=[1 2 3] y indparamfijos=[]%% jri 26-Sep-2012% agv 17Dic2018 introducidas funciones para usar Jacobiano o no% To check if the Jacobian is correct% options=optimset (oldoptions, 'FinDiffType', 'central','DerivativeCheck','on', 'Display', 'final-detailed', 'Jacobian', 'on'); %Opciones de ajuste para lsqnonlin. Jacobiano activado para reducir el nº de iteraciones oldoptions=optimset('lsqnonlin');if exist(strcat(funcAjuste,'_jac'), 'file')==2 % If the analitic jacobian file exists, use it    options=optimset (oldoptions, 'FinDiffType', 'central', 'Display', 'final-detailed', 'Jacobian', 'on'); %Opciones de ajuste para lsqnonlin. Jacobiano activado para reducir el nº de iteraciones     [paramfitY, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, J]=lsqnonlin(@err_ajsGlobalGral_Jac, valorParamVarIni, LB, UB, ...    options, data_all, numPtosxCurva, varGlobales, indParamsGlobal2Indep, indparamvariables, indparamfijos, valorparamfijos, varFix, funcAjuste); %Ajuste global por mínimos cuadradoselse    disp('No Jacobian file entered. Fitting without analitic Jacobian...')    options=optimset (oldoptions, 'FinDiffType', 'central', 'Display', 'final-detailed', 'Jacobian', 'off');    options.MaxFunctionEvaluations = 10000; % Without Jacobian the convergence may be slower    [paramfitY, resnorm, resfun, EXITFLAG, OUTPUT, LAMBDA, J]=lsqnonlin(@err_ajsGlobalGral_NoJac, valorParamVarIni, LB, UB, ...    options, data_all, numPtosxCurva, varGlobales, indParamsGlobal2Indep, indparamvariables, indparamfijos, valorparamfijos, varFix, funcAjuste); %Ajuste global por mínimos cuadradosend    numtotalparams = numel(indparamvariables)+numel(indparamfijos);allparam = zeros (1, numtotalparams);allparam (indparamfijos) = valorparamfijos;allparam (indparamvariables) = paramfitY;